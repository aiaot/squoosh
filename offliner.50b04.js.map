{"version":3,"sources":["webpack:///./node_modules/idb-keyval/dist/idb-keyval.mjs","webpack:///./src/lib/offliner.ts"],"names":["__webpack_require__","d","__webpack_exports__","get","set","Store","[object Object]","dbName","storeName","this","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","key","req","_withIDBStore","value","put","r","__webpack__serviceworker__1","offliner","mainAppLoaded","idb_keyval__WEBPACK_IMPORTED_MODULE_0__","async","updateReady","reg","waiting","installing","addEventListener","once","installingWorker","state","showSnack","PRERENDER","navigator","serviceWorker","register","hasController","controller","location","reload","timeout","getRegistration","actions","postMessage","skipWaiting","Object","active","getMostActiveServiceWorker"],"mappings":"qFAAAA,EAAAC,EAAAC,EAAA,sBAAAC,IAAAH,EAAAC,EAAAC,EAAA,sBAAAE,IAAA,MAAAC,EACAC,YAAAC,EAAA,eAAAC,EAAA,UACAC,KAAAD,YACAC,KAAAC,KAAA,IAAAC,QAAA,CAAAC,EAAAC,KACA,MAAAC,EAAAC,UAAAC,KAAAT,EAAA,GACAO,EAAAG,QAAA,KAAAJ,EAAAC,EAAAI,QACAJ,EAAAK,UAAA,KAAAP,EAAAE,EAAAM,SAEAN,EAAAO,gBAAA,MACAP,EAAAM,OAAAE,kBAAAd,OAIAF,cAAAiB,EAAAC,GACA,OAAAf,KAAAC,KAAAe,KAAAC,GAAA,IAAAf,QAAA,CAAAC,EAAAC,KACA,MAAAc,EAAAD,EAAAC,YAAAlB,KAAAD,UAAAe,GACAI,EAAAC,WAAA,KAAAhB,KACAe,EAAAE,QAAAF,EAAAV,QAAA,KAAAJ,EAAAc,EAAAT,QACAM,EAAAG,EAAAG,YAAArB,KAAAD,gBAIA,IAAAuB,EACA,SAAAC,IAGA,OAFAD,IACAA,EAAA,IAAA1B,GACA0B,EAEA,SAAA5B,EAAA8B,EAAAF,EAAAC,KACA,IAAAE,EACA,OAAAH,EAAAI,cAAA,WAAAJ,IACAG,EAAAH,EAAA5B,IAAA8B,KACKR,KAAA,IAAAS,EAAAd,QAEL,SAAAhB,EAAA6B,EAAAG,EAAAL,EAAAC,KACA,OAAAD,EAAAI,cAAA,YAAAJ,IACAA,EAAAM,IAAAD,EAAAH,uCCpCAjC,EAAAsC,EAAApC,GAAA,SAAAqC,GAAAvC,EAAAC,EAAAC,EAAA,6BAAAsC,IAAAxC,EAAAC,EAAAC,EAAA,kCAAAuC,IAAA,IAAAC,EAAA1C,EAAA,IAgCA2C,eAAeC,EAAYC,GACzB,GAAIA,EAAIC,QAAS,OACjB,MAAMC,QAdRJ,eAAgCE,GAC9B,OAAIA,EAAIE,WAAmBF,EAAIE,WACxB,IAAIpC,QAAwBC,IACjCiC,EAAIG,iBACF,cACA,IAAMpC,EAAQiC,EAAIE,YAClB,CAAEE,MAAM,MAQaC,CAAiBL,GAC1C,OAAO,IAAIlC,QAAeC,IACxBmC,EAAWC,iBAAiB,cAAe,KAChB,cAArBD,EAAWI,OAAuBvC,QAMrC+B,eAAeH,EAASY,GAE7B,GAAyB,kBAAdC,UAAyB,OAGlCC,UAAUC,cAAcC,SAASjB,GAGnC,MAAMkB,IAAkBH,UAAUC,cAAcG,WAgBhD,GAbAJ,UAAUC,cAAcP,iBAAiB,mBAAoBL,UAEtDc,EAMLE,SAASC,SALPR,EAAU,wBAAyB,CAAES,QAAS,SAU7CJ,EAAe,OAEpB,MAAMZ,QAAYS,UAAUC,cAAcO,kBAErCjB,UAECD,EAAYC,GASH,iBANMO,EAAU,mBAAoB,CACjDW,QAAS,CAAC,SAAU,cAvExBpB,iBACE,MAAME,QAAYS,UAAUC,cAAcO,kBACrCjB,GAAQA,EAAIC,SACjBD,EAAIC,QAAQkB,YAAY,gBAyECC,IAOpBtB,eAAeF,IAGpB,SAD6ByB,OAAAxB,EAAA,EAAAwB,CAAyB,mBAClC,OACpBA,OAAAxB,EAAA,EAAAwB,CAAI,mBAAmB,GACvB,MAAMX,QAjFRZ,iBACE,MAAME,QAAYS,UAAUC,cAAcO,kBAC1C,OAAKjB,EACEA,EAAIsB,QAAUtB,EAAIC,SAAWD,EAAIE,WADvB,KA+EWqB,GACvBb,GACLA,EAAcS,YAAY","file":"offliner.50b04.js","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import { get, set } from 'idb-keyval';\n\n// Just for TypeScript\nimport SnackBarElement from './SnackBar';\n\n/** Tell the service worker to skip waiting */\nasync function skipWaiting() {\n  const reg = await navigator.serviceWorker.getRegistration();\n  if (!reg || !reg.waiting) return;\n  reg.waiting.postMessage('skip-waiting');\n}\n\n/** Find the service worker that's 'active' or closest to 'active' */\nasync function getMostActiveServiceWorker() {\n  const reg = await navigator.serviceWorker.getRegistration();\n  if (!reg) return null;\n  return reg.active || reg.waiting || reg.installing;\n}\n\n/** Wait for an installing worker */\nasync function installingWorker(reg: ServiceWorkerRegistration): Promise<ServiceWorker> {\n  if (reg.installing) return reg.installing;\n  return new Promise<ServiceWorker>((resolve) => {\n    reg.addEventListener(\n      'updatefound',\n      () => resolve(reg.installing!),\n      { once: true },\n    );\n  });\n}\n\n/** Wait a service worker to become waiting */\nasync function updateReady(reg: ServiceWorkerRegistration): Promise<void> {\n  if (reg.waiting) return;\n  const installing = await installingWorker(reg);\n  return new Promise<void>((resolve) => {\n    installing.addEventListener('statechange', () => {\n      if (installing.state === 'installed') resolve();\n    });\n  });\n}\n\n/** Set up the service worker and monitor changes */\nexport async function offliner(showSnack: SnackBarElement['showSnackbar']) {\n  // This needs to be a typeof because Webpack.\n  if (typeof PRERENDER === 'boolean') return;\n\n  if (process.env.NODE_ENV === 'production') {\n    navigator.serviceWorker.register('../sw');\n  }\n\n  const hasController = !!navigator.serviceWorker.controller;\n\n  // Look for changes in the controller\n  navigator.serviceWorker.addEventListener('controllerchange', async () => {\n    // Is it the first install?\n    if (!hasController) {\n      showSnack('Ready to work offline', { timeout: 5000 });\n      return;\n    }\n\n    // Otherwise reload (the user will have agreed to this).\n    location.reload();\n  });\n\n  // If we don't have a controller, we don't need to check for updates â€“ we've just loaded from the\n  // network.\n  if (!hasController) return;\n\n  const reg = await navigator.serviceWorker.getRegistration();\n  // Service worker not registered yet.\n  if (!reg) return;\n  // Look for updates\n  await updateReady(reg);\n\n  // Ask the user if they want to update.\n  const result = await showSnack('Update available', {\n    actions: ['reload', 'dismiss'],\n  });\n\n  // Tell the waiting worker to activate, this will change the controller and cause a reload (see\n  // 'controllerchange')\n  if (result === 'reload') skipWaiting();\n}\n\n/**\n * Tell the service worker the main app has loaded. If it's the first time the service worker has\n * heard about this, cache the heavier assets like codecs.\n */\nexport async function mainAppLoaded() {\n  // If the user has already interacted, no need to tell the service worker anything.\n  const userInteracted = await get<boolean | undefined>('user-interacted');\n  if (userInteracted) return;\n  set('user-interacted', true);\n  const serviceWorker = await getMostActiveServiceWorker();\n  if (!serviceWorker) return; // Service worker not installing yet.\n  serviceWorker.postMessage('cache-all');\n}\n"],"sourceRoot":""}